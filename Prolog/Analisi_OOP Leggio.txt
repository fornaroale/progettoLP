def-class:
	def-class(nomeClasse, [Parents], [Slot_Values]) --> Slot_Values = [nomeAtt = 'Value' ... nomeMethod = method([], <predicato1, predicato2,..., predN>)]
	
	Splitta le informazioni e aggiorna la B.C. tramite assert:
		La base di conscenza conterrà:
			class(nomeClass).
			superclass(nomeCl, [Parents]).
			slot_value(nomeCl, [Value][Methods]). -> Dovrebbe usare split_value per memorizzare la lista in modo da usare il predicato per estrarre
													 i metodi, ma per ora calcola la stringa ma non me la restituisce 

new/2:
	new(nomeIstanza, nomeCl), che richiama new(nomeIstanza, nomeCl, []). --> la lista conterrà i valori.
	
	Verifica che esista un predicato class(nomeCl) corrispondente
		Se è verificato, verifica l'esistenza degli attributi di cui si intende modificare il valore andando a verificare che esista un predicato 
		Slot_Value che corrisponda a quella classe e che nella lista [Values] corrispondente esistano quegli attributi
			Se è verificata anche l'esistenza degli attributi, crea un predicato in questo modo:
				assert(instance_of(nomeIstanza, [nomeClasse, [Slot_Values]])).
		Altrimenti segnala un errore
	Altrimenti segnala un errore
	

	

getv:
	getv(nomeIstanza, attributo, risultato)
	
	Verifica l'esistenza del predicato instance_of corrispondente, verificare se esistono gli attributi èinutile perchè viene già fatto nella new, e se
	non esistono l'istanza non viene creata.
	
	Se è verificata, accede all'attributo slot_values del predicato instance_of corrispondente, prende il secondo elemento e cerca il valore 
	corrispondente
	
	
getvX:
	getvX(nomeIstanza, [Attributi], [Risultato]).
	
	Richiama la getv su ogni attributo.